clear allclose all%This script is an introduction to some basic aspects of time series%analysis.  You will make a signal +/- noise.  Next, you have options to%low pass filter or difference the data.  You wil then look at the spectra resulting from these operations.%Finally, there is an application to upward continuation at the end.%Note, you may wish to uncomment the 'pause' commands so that you can work%thru each part at your own pace.%$generate a synthetic signal over the interval [0 , 2*pi]steps = 100;x=linspace(0,2*pi,steps);%generate a vector of phases for your synthetic signalsizev= 3;  %# fourier componentscolumn = 1; %1 to make a single vector that is sizev x column%vector of phasesphase=2*pi*(rand(sizev,column)); %radians%vector of amplitudesamplitude = rand(sizev,column);j=0;sumsig=0;for j = 1:length(phase)    Asinphase(:,j) = amplitude(j).*sin(phase(j).*x);    sumsig = sumsig+Asinphase(:,j);        sumsig = sumsig+Asinphase(:,j);     %plot each contribution to the signal, in turn  figure(2) subplot(2,1,1),plot(x,Asinphase(:,j)) hold on %plot combined signal as it emerges subplot(2,1,2),plot(x,sumsig)end%plot summed series composed of the terms in the expansionfigure(3),subplot(2,1,1),plot(x,sumsig)hold on%Add some white noise to your signal that is a factor 'scalefactor' of the%max amplitude variationsscalefactor = 0.25;randomphase = 2*pi*rand(length(x),column);noise = scalefactor.*randn(length(x),1).*exp(randomphase .* i);figure,plot(x,noise)sumsig = sumsig + noise;figure,plot(x,sumsig)%Add a secular trend defined as 'trend'aa=0.2;      %amplitude should be small in comparison to 1 or all you will see is trend (which is ok too!)trend = aa*x.^2;   %make this whatever you want it to besumsig=sumsig+trend';     figure,plot(x,sumsig)%plot whole space series composed of the terms in the expansionfigure(3),subplot(2,1,2),plot(x,sumsig)title('The dataset')%pauseyy = sumsig;%subsample if needed% interval = 1;% jj=0;% for i = 1:interval:length(x)%    jj=jj+1;%    x(jj) = x(i);%    yy(jj) = yy(i);% end%get the length of the series and data spacing%nx=length(yy);        %Number of points in the dataset   L = length(x);        %Input this or use length() commanddx=L/nx;             %SpacingNyquist = 0.5*(1/dx);   %low pass filter if needed%A low pass filter: Remove frequencies above Nyquist to avoid aliasing%Butterowrth filter.  Multiply by transfer function%H(iw) = |out| / |in| ; numerator and denominator are polynomials of order%'order'.  Sharpness of cutoff increases with order at expense of%information.  Cutoff is frequency below which signals are permitted.cutoff = 1;                           %low pass frequency cutoff in fractions of Nyquist; 1=Nyquistmaxfreq = cutoff * Nyquist;order = 6;[out in] = butter( order , maxfreq);yy = filter( out , in , yy);qq = yy;%for NO filtering before analysis%yy=sumsig;%  remove the mean and window the profile to minimize edge effects%Make sure there is no secular trend before doing this.  If there is%difference the data first and work with this data instead. This is the%same as multiplying the time series exp(ikx) by (i*2pi*k) and so the lowest%wavenumbers are vastly reduced in amplitude (longest period trend in the%data goes away).  This operation will pump up high frequencies.  If you do%this for a real project, compare with what happens if you remove a%polynomial for the secular trend in the data.diffyy = diff(yy);%Window the data      window=hanning(nx);   y=(yy-mean(yy)).*window;   %Window the differenced data     diffnx=length(diffyy);        %Number of points in the dataset   window=hanning(diffnx);   diffy=(diffyy-mean(diffyy)).*window;   %Instead of differencing, remove a polynomial fit to any secular trend in%the data.  Compare the results      % %  POLYFIT Fit polynomial to data.% %     P = POLYFIT(X,Y,N) finds the coefficients of a polynomial P(X) of% %     degree N that fits the data Y best in a least-squares sense. P is a% %     row vector of length N+1 containing the polynomial coefficients in% %     descending powers, P(1)*X^N + P(2)*X^(N-1) +...+ P(N)*X + P(N+1).% % % fitCoeff = polyfit(x,yy,8);% fity=polyval(fitCoeff, x);% % figure(91)% % plot(x,fity,'r')% % hold on% % plot(x,yy)% % premove= yy - fity;         %Data with polynnomial removed%yy=premove;   %  generate the wavenumber or frequency.  if these wavenumbers are wrong the%  answer will be wrong and the imaginary part of the result will%  be large.%   k = -nx/2:(nx/2-1);   k = k'./L;       % Calculate the FFT z = real(fftshift(fft(y)));zi = imag(fftshift(fft(y)));power = abs(z).^2;znowindow = real(fftshift(fft((yy-mean(yy)))));powernowindow = abs(znowindow).^2;% Calculate the FFT with differenced data: Taking the derivative is the% same as multiplying your signal A*exp(-i*wn*t) by (i*wn) so you will lose% low frequencies (including any secular trend in your data-- i.e, the% longest period in your data) and pump up high frequencies.diffz = real(fftshift(fft(diffy)));diffpower = abs(diffz).^2;phase=atan(zi./z);scalepower = 1.0;figure(9); clf;figure(9)hold onsubplot(3,1,1),plot(x,sumsig,'r')subplot(3,1,1),plot(x,yy,'b',x,sumsig,'r')subplot(3,1,1),plot(x,yy./(max(yy)*scalepower))title('Analysis of unwindowed data with zero mean; Blue = low pass filtered (if turned on)') xlabel('x')ylabel('y(x)')subplot(3,1,3), semilogx(1./k,powernowindow./(max(powernowindow)*scalepower),'b--')xlabel('Period')ylabel('normalized power')%pausefigure(10); clf;figure(10)hold onsubplot(3,1,1),plot(x,yy./(max(yy)*scalepower))title('Analysis of windowed data with zero mean')xlabel('x')ylabel('y(x)')subplot(3,1,2), plot(x,y./(max(y))*scalepower)xlabel('x')ylabel('windowed y(x)')subplot(3,1,3), semilogx(1./k,power./(max(power)*scalepower),'b--')xlabel('Period')ylabel('normalized power')%pause%Differenced data with zero meani = 1:1:(L-1);x = x(i);kp = k(i);figure(11); clf;figure(11)hold onsubplot(3,1,1),plot(x,abs(diffyy./(max(diffyy)*scalepower)))title('Analysis of windowed and differenced data with zero mean: bl=not diff; r=diff')xlabel('x')ylabel('diff y(x)')subplot(3,1,2), plot(x,abs(diffy./(max(diffyy)*scalepower)))xlabel('x')ylabel('windowed diff y(x)')subplot(3,1,3), semilogx(1./kp,diffpower./(max(diffpower)*scalepower),'r--')hold onsemilogx(1./k,power./max(power),'b--')xlabel('Period')ylabel('normalized power')